// Jenkins pipeline declarativo para construir y publicar la imagen Docker (Kaniko en K8s),
// actualizar el chart Helm (image.tag) y hacer push a Git para que ArgoCD sincronice.
// Notas:
// - Solo usa tags SemVer (sin latest), acorde a la política del proyecto.
// - Los agentes se ejecutan en Kubernetes usando un podTemplate con contenedores 'kaniko' y 'git'.
// - Se deja margen de recursos (>15%) y el nodeSelector apunta al pool nuevo de 4 vCPU/8GB.
pipeline {
  agent {
    kubernetes {
      defaultContainer 'git'
      // Definición del Pod del agente en K8s: afinidad al pool potente y recursos de cada contenedor.
      yaml """
apiVersion: v1
kind: Pod
spec:
  nodeSelector:
    doks.digitalocean.com/node-pool: pool-9x07hzzwz
  containers:
    - name: kaniko  # Construye y publica la imagen sin Docker daemon
      image: gcr.io/kaniko-project/executor:v1.23.2-debug
      command:
        - cat
      tty: true
      volumeMounts:
        - name: kaniko-secret
          mountPath: /kaniko/.docker
      resources:
        requests:
          cpu: "800m"
          memory: "1Gi"
        limits:
          cpu: "2"
          memory: "2Gi"
    - name: git  # Utilidades de Git para modificar el repo y hacer commit/push
      image: alpine/git:2.45.2
      command:
        - cat
      tty: true
      resources:
        requests:
          cpu: "100m"
          memory: "128Mi"
        limits:
          cpu: "300m"
          memory: "256Mi"
  volumes:
    - name: kaniko-secret
      emptyDir: {}
"""
    }
  }

  parameters {
    // Opcional: si está vacío, el pipeline derivará la versión desde el commit de merge a main
    string(name: 'APP_VERSION', defaultValue: '', description: 'SemVer x.y.z. Si se deja vacío en builds de main, se toma de release/x.y.z (rama origen del merge)')
  }

  environment {
    IMAGE_REPO = 'ivan150/pedidos-api'
    CHART_VALUES = 'charts/pedido-app/values.yaml'
  }

  stages {
    // Etapa 1: obtiene la versión (desde parámetro o desde el commit de merge) y valida SemVer.
    stage('Validar versión') {
      steps {
        script {
          // 1) Derivar versión desde el/los mensajes de commit buscando ramas release/x.y.z
          //    Revisamos los últimos 5 commits por robustez ante squash/rebases.
          def vParam = (params.APP_VERSION ?: '').trim()
          // Evita "dubious ownership" al leer historial en contenedor efímero
          sh 'git config --global --add safe.directory "$WORKSPACE" || true'
          def logs = sh(returnStdout: true, script: 'git log -5 --pretty=%B').trim()
          echo "Últimos mensajes de commit (recortados): ${logs.take(200)}..."
          def m = (logs =~ /release\/(\d+\.\d+\.\d+)/)
          def vDerived = m.find() ? m.group(1) : ''
          if (vDerived) {
            echo "APP_VERSION derivado de commits: ${vDerived}"
          } else {
            echo "No se encontró patrón release/x.y.z en los últimos commits"
          }

          // Preferimos la versión derivada cuando hay cambios en main por webhook.
          // Si el job es manual y se pasó APP_VERSION, se respeta; de lo contrario usamos vDerived.
          def v = vDerived ?: vParam

          // 2) Normalización robusta: recorta y sustituye separadores por punto
          echo "APP_VERSION raw='${v ?: params.APP_VERSION}'"
          v = (v ?: '').trim()
          v = v
            .replaceAll('[^0-9]', '.')
            .replaceAll('\\.+', '.')
            .replaceAll('^\\.|\\.$', '')
          echo "APP_VERSION normalizado='${v}'"
          if (v == 'latest') {
            error 'No se permite usar la etiqueta mutable latest'
          }
          if (!(v ==~ /^\d+\.\d+\.\d+$/)) {
            error "APP_VERSION debe ser SemVer x.y.z (ej. 0.1.4). Recibido param='${params.APP_VERSION}', derivado='${v}'"
          }
          // Propaga la versión normalizada al entorno para el resto de stages
          env.APP_VERSION = v
          // Capturamos el commit SHA actual para etiquetar la imagen (labels OCI)
          env.GIT_SHA = sh(returnStdout: true, script: 'git rev-parse HEAD').trim()
        }
      }
    }

    // Etapa 2: escribe /kaniko/.docker/config.json con el token de Docker Hub (para push)
    stage('Configurar credenciales Docker para Kaniko') {
      steps {
        container('kaniko') {
          withCredentials([usernamePassword(credentialsId: 'dockerhub-credentials', usernameVariable: 'DOCKER_USER', passwordVariable: 'DOCKER_PASS')]) {
            sh '''
              AUTH=$(printf '%s' "$DOCKER_USER:$DOCKER_PASS" | base64 | tr -d '\n')
              mkdir -p /kaniko/.docker
              cat > /kaniko/.docker/config.json <<EOF
              {"auths":{"https://index.docker.io/v1/":{"auth":"${AUTH}"}}}
EOF
              chmod 600 /kaniko/.docker/config.json
            '''
          }
        }
      }
    }

    // Etapa 3: construye y publica la imagen con Kaniko hacia ${IMAGE_REPO}:${APP_VERSION}
    stage('Build & Push (Kaniko)') {
      steps {
        container('kaniko') {
          sh '''
            /kaniko/executor \
              --context $WORKSPACE \
              --dockerfile backend/Dockerfile \
              --cache=false \
              --reproducible \
              --build-arg GIT_SHA=${GIT_SHA} \
              --build-arg APP_VERSION=${APP_VERSION} \
              --destination ${IMAGE_REPO}:${APP_VERSION} \
              --cleanup
          '''
        }
      }
    }

    // Etapa 4: actualiza el tag en charts/pedido-app/values.yaml de forma portable con awk
    stage('Bump image.tag en Helm values') {
      steps {
        container('git') {
          sh '''
            echo "Actualizando ${CHART_VALUES} a tag ${APP_VERSION}"
            # Actualiza de forma portable (POSIX) el valor de image.tag usando awk
            awk -v newtag="\"${APP_VERSION}\"" '
              BEGIN{updated=0}
              /^[[:space:]]*tag[[:space:]]*:/ {
                # conserva el indentado y la clave exacta
                sub(/tag[[:space:]]*:.*/, "tag: " newtag);
                updated=1;
                print; next
              }
              {print}
              END{ if(!updated){ exit 1 } }
            ' ${CHART_VALUES} > ${CHART_VALUES}.tmp && mv ${CHART_VALUES}.tmp ${CHART_VALUES}

            echo 'Preview del cambio:'
            grep -n -E 'repository:|tag:' ${CHART_VALUES} | sed -n '1,20p'
          '''
        }
      }
    }

    // Etapa 5: commit y push a main usando PAT de GitHub (x-access-token)
    stage('Commit & Push') {
      steps {
        container('git') {
          withCredentials([usernamePassword(credentialsId: 'github-credentials', usernameVariable: 'GIT_USER', passwordVariable: 'GIT_PASS')]) {
            sh '''
              set -e
              cd "$WORKSPACE"
              # Marca el workspace como seguro y configura identidad
              git config --global --add safe.directory "$WORKSPACE" || true
              git config user.name "jenkins-bot"
              git config user.email "jenkins-bot@local"

              # Añade solo si hay cambios
              git add ${CHART_VALUES}
              if ! git diff --cached --quiet; then
                git commit -m "ci: bump image.tag to ${APP_VERSION}"
              else
                echo "No hay cambios para commitear"
              fi

              # Evita prompts interactivos y empuja usando PAT recomendado por GitHub
              export GIT_TERMINAL_PROMPT=0
              git remote set-url origin https://github.com/ivanlozanoq/proyecto-mobiapp.git
              # Forma recomendada por GitHub: usuario x-access-token y el token como password
              git push https://x-access-token:${GIT_PASS}@github.com/ivanlozanoq/proyecto-mobiapp.git HEAD:main
            '''
          }
        }
      }
    }
  }
}

