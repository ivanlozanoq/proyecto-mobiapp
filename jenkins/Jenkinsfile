// Jenkins pipeline declarativo para construir y publicar la imagen Docker (Kaniko en K8s),
// actualizar el chart Helm (image.tag) y hacer push a Git para que ArgoCD sincronice.
// Notas:
// - Solo usa tags SemVer (sin latest), acorde a la política del proyecto.
// - Los agentes se ejecutan en Kubernetes usando un podTemplate con contenedores 'kaniko' y 'git'.
// - Se deja margen de recursos (>15%) y el nodeSelector apunta al pool nuevo de 4 vCPU/8GB.
pipeline {
  agent {
    kubernetes {
      defaultContainer 'git'
      // Definición del Pod del agente en K8s: afinidad al pool potente y recursos de cada contenedor.
      yaml """
apiVersion: v1
kind: Pod
spec:
  nodeSelector:
    doks.digitalocean.com/node-pool: pool-9x07hzzwz
  containers:
    - name: kaniko  # Construye y publica la imagen sin Docker daemon
      image: gcr.io/kaniko-project/executor:v1.23.2-debug
      command:
        - cat
      tty: true
      volumeMounts:
        - name: kaniko-secret
          mountPath: /kaniko/.docker
      resources:
        requests:
          cpu: "800m"
          memory: "1Gi"
        limits:
          cpu: "2"
          memory: "2Gi"
    - name: git  # Utilidades de Git para modificar el repo y hacer commit/push
      image: alpine/git:2.45.2
      command:
        - cat
      tty: true
      resources:
        requests:
          cpu: "100m"
          memory: "128Mi"
        limits:
          cpu: "300m"
          memory: "256Mi"
  volumes:
    - name: kaniko-secret
      emptyDir: {}
"""
    }
  }

  parameters {
    string(name: 'APP_VERSION', defaultValue: '0.1.4', description: 'Nueva versión SemVer (x.y.z), NO usar latest')
  }

  environment {
    IMAGE_REPO = 'ivan150/pedidos-api'
    CHART_VALUES = 'charts/pedido-app/values.yaml'
  }

  stages {
    // Etapa 1: valida y normaliza APP_VERSION (SemVer x.y.z) y la propaga al entorno.
    stage('Validar versión') {
      steps {
        script {
          // Diagnóstico: mostrar exactamente qué llega desde la UI
          echo "APP_VERSION raw='${params.APP_VERSION}'"
          // Normalización robusta: recorta espacios y sustituye cualquier separador por punto
          def vRaw = (params.APP_VERSION ?: '')
          def v = vRaw.trim()
          v = v
            .replaceAll('[^0-9]', '.')  // todo lo no dígito a punto (maneja guiones, comas, puntos raros)
            .replaceAll('\\.+', '.')    // colapsa múltiples puntos en uno
            .replaceAll('^\\.|\\.$', '') // quita punto inicial/final
          echo "APP_VERSION normalizado='${v}'"
          if (v == 'latest') {
            error 'No se permite usar la etiqueta mutable latest'
          }
          if (!(v ==~ /^\d+\.\d+\.\d+$/)) {
            error "APP_VERSION debe ser SemVer x.y.z (ej. 0.1.4). Recibido raw='${params.APP_VERSION}', normalizado='${v}'"
          }
          // Propaga la versión normalizada al entorno para el resto de stages
          env.APP_VERSION = v
        }
      }
    }

    // Etapa 2: escribe /kaniko/.docker/config.json con el token de Docker Hub (para push)
    stage('Configurar credenciales Docker para Kaniko') {
      steps {
        container('kaniko') {
          withCredentials([usernamePassword(credentialsId: 'dockerhub-credentials', usernameVariable: 'DOCKER_USER', passwordVariable: 'DOCKER_PASS')]) {
            sh '''
              AUTH=$(printf '%s' "$DOCKER_USER:$DOCKER_PASS" | base64 | tr -d '\n')
              mkdir -p /kaniko/.docker
              cat > /kaniko/.docker/config.json <<EOF
              {"auths":{"https://index.docker.io/v1/":{"auth":"${AUTH}"}}}
EOF
              chmod 600 /kaniko/.docker/config.json
            '''
          }
        }
      }
    }

    // Etapa 3: construye y publica la imagen con Kaniko hacia ${IMAGE_REPO}:${APP_VERSION}
    stage('Build & Push (Kaniko)') {
      steps {
        container('kaniko') {
          sh '''
            /kaniko/executor \
              --context $WORKSPACE \
              --dockerfile backend/Dockerfile \
              --destination ${IMAGE_REPO}:${APP_VERSION} \
              --cleanup
          '''
        }
      }
    }

    // Etapa 4: actualiza el tag en charts/pedido-app/values.yaml de forma portable con awk
    stage('Bump image.tag en Helm values') {
      steps {
        container('git') {
          sh '''
            echo "Actualizando ${CHART_VALUES} a tag ${APP_VERSION}"
            # Actualiza de forma portable (POSIX) el valor de image.tag usando awk
            awk -v newtag="\"${APP_VERSION}\"" '
              BEGIN{updated=0}
              /^[[:space:]]*tag[[:space:]]*:/ {
                # conserva el indentado y la clave exacta
                sub(/tag[[:space:]]*:.*/, "tag: " newtag);
                updated=1;
                print; next
              }
              {print}
              END{ if(!updated){ exit 1 } }
            ' ${CHART_VALUES} > ${CHART_VALUES}.tmp && mv ${CHART_VALUES}.tmp ${CHART_VALUES}

            echo 'Preview del cambio:'
            grep -n -E 'repository:|tag:' ${CHART_VALUES} | sed -n '1,20p'
          '''
        }
      }
    }

    // Etapa 5: commit y push a main usando PAT de GitHub (x-access-token)
    stage('Commit & Push') {
      steps {
        container('git') {
          withCredentials([usernamePassword(credentialsId: 'github-credentials', usernameVariable: 'GIT_USER', passwordVariable: 'GIT_PASS')]) {
            sh '''
              set -e
              cd "$WORKSPACE"
              # Marca el workspace como seguro y configura identidad
              git config --global --add safe.directory "$WORKSPACE" || true
              git config user.name "jenkins-bot"
              git config user.email "jenkins-bot@local"

              # Añade solo si hay cambios
              git add ${CHART_VALUES}
              if ! git diff --cached --quiet; then
                git commit -m "ci: bump image.tag to ${APP_VERSION}"
              else
                echo "No hay cambios para commitear"
              fi

              # Evita prompts interactivos y empuja usando PAT recomendado por GitHub
              export GIT_TERMINAL_PROMPT=0
              git remote set-url origin https://github.com/ivanlozanoq/proyecto-mobiapp.git
              # Forma recomendada por GitHub: usuario x-access-token y el token como password
              git push https://x-access-token:${GIT_PASS}@github.com/ivanlozanoq/proyecto-mobiapp.git HEAD:main
            '''
          }
        }
      }
    }
  }
}

